= Kodein-DB
:version: 0.1.0

Multiplatform Kotlin embedded NoSQL database.


== Introduction

=== Description

Kodein DB is an embedded NoSQL database that works on JVM, Android, Kotlin/Native and iOS.
It is suited for client or mobile applications.

CAUTION: Under no circumstances should it be used in a server!

.Kodein-DB allows you to:
- Easily store, retrieve and query kotlin objects.
- Stop carrying about schema definitions.
- Easily set up a new project.

.Kodein-DB is a good choice because it:
- proposes a very simple and readable DSL.
- integrates nicely with Android and iOS.
- offers very good performances.
- is just Kotlin!


=== Example

[source,kotlin]
.A simple example:
----
val db = DB.open("path/to/db")

db.put(User("John", "Doe"))
db.put(User("Jane", "Doe"))
db.put(User("Someone", "Else"))

val does = db.find<User>().byIndex("lastName", "Doe").models()
println(does.joinToString()) // Jane, John
----


== Install

[IMPORTANT]
====
**Kodein-DB is in beta.**

Although, we do use Kodein-DB in production, this means we cannot ensure the library's correctness and stability.
Therefore, we ask that you first try Kodein-DB in non-critical applications, and report any mis-behaviour you may encounter.
====

=== JVM

Add the repository:

[source,groovy]
.build.gradle
----
buildscript {
    repositories {
        maven { url "https://dl.bintray.com/kodein-framework/Kodein-DB" }
    }
}
----

NOTE: Kodein-DB will eventually be sync'd with JCenter, when it exits beta.

Then add the dependency:

[source,groovy,subs=attributes+]
.build.gradle
----
dependencies {
    implementation 'org.kodein.db:kodein-db-jvm:{version}'
}
----

NOTE: If you are developing a library and not an application, use the artifact `org.kodein.db:kodein-db-api-jvm:{version}` instead, which only provides the Kodein-DB API, and not its implementation.

Furthermore, you need to add the serializer you are going to use.
When targetting JVM only, you can use https://github.com/EsotericSoftware/kryo[Kryo]:

[source,groovy,subs=attributes+]
.build.gradle
----
dependencies {
    implementation 'org.kodein.db:kodein-db-serializer-kryo-jvm:{version}'
}
----

Finally, if you are targeting a desktop OS, you must add the OS specific leveldb native build dependency:

[source,groovy,subs=attributes+]
.build.gradle
----
dependencies {
    implementation 'org.kodein.db:kodein-leveldb-jni-linux:{version}' // 'linux' or 'macos'
}
----

NOTE: If you are targeting multiple desktop OS, it is OK to add multiple `kodein-leveldb-jni-*` dependencies.


=== Multiplatform and/or Native (Gradle)

NOTE: Kodein-DB supports the following targets: +
      iosArm32, iosArm64, iosX64, linuxX64, macosX64, mingwX64

Kodein-DB uses the new gradle native dependency model, which is experimental in gradle.
You need to enable it in your `settings.gradle` file:

[source,groovy]
.settings.gradle
----
enableFeaturePreview("GRADLE_METADATA")
----

Then, in your `build.gradle` file, add the repository:

[source,groovy]
.build.gradle
----
buildscript {
    repositories {
        maven { url "https://dl.bintray.com/kodein-framework/Kodein-DB" }
    }
}
----

NOTE: Kodein-DB will eventually be sync'd with JCenter, when it exits beta.

Then add the dependency:

[source,groovy,subs=attributes+]
.build.gradle
----
kotlin {
    sourceSets {
        commonMain {
            dependencies {
                implementation "org.kodein.db:kodein-db:{version}"
            }
        }
    }
}
----

Thanks to Gradle Metadata, you don't need to add any additional dependency to your targets.

NOTE: If you are developing a library and not an application, use the artifact `org.kodein.db:kodein-db-api:{version}` instead, which only provides the Kodein-DB API, and not its implementation.

Furthermore, you need to add the serializer you are going to use.
When targetting Multiplatform, you need to use https://github.com/Kotlin/kotlinx.serialization[KotlinX Serialization]:

[source,groovy,subs=attributes+]
.build.gradle
----
kotlin {
    sourceSets {
        commonMain {
            dependencies {
                implementation 'org.kodein.db:kodein-db-serializer-kotlinx:{version}'
            }
        }
    }
}
----


== Immutability requirement

Kodein-DB works under the assumption that your models (ie. the objects that are going to be managed by the database) are immutable.
This can be seen as paradoxical for a database library: you need to be able to update your data!

Kodein-DB is a document based NoSQL library, it works much like a folder drawer.

- Inserting a document is like printing a new document and putting it inside the appropriate drawer at the correct position.
- Updating a document is like printing the updated document, and putting it inside the drawer, removing the old outdated document.

With this analogy, you can see that the document themselves are immutable: you do not scrible over a document, you print a new version to replace the old one.

Kodein-DB works the same way: each of your object model must be immutable, and you should create a new model to update one:

[source,kotlin]
.A simple example:
----
val john = db[johnKey] ?: error("No John!")
db.put(john.copy(phone = "0605040302"))
----

IMPORTANT: There is no way (yet?) in Kotlin to ensure immutability.
           While we cannot force you to use immutable models, we highly recommend that you do.
           Using mutable models will eventually lead to data races, and very hard to find bugs.


== Opening a database

=== Open statement

To open a new database, use `DB.factory`:

[source,kotlin]
.Opening a database:
----
val db = DB.open("path/to/db")
----

By default, Kodein-DB will create the database if it does not exist.
If you want to modify this behaviour, you can use:

- `LevelDB.OpenPolicy.OPEN`: fails if the database does not already exist
- `LevelDB.OpenPolicy.CREATE`: fails if the database already exists

[source,kotlin]
.Opening an existing database:
----
val db = DB.open("path/to/db", LevelDB.OpenPolicy.OPEN)
----

=== Defining the serializer

If you are targeting JVM only, then Kodein-DB will find the serializer by itself, so you don't need to define it. +
However, when targeting Multiplatform, you need to define the KotlinX serializer and the serialized classes manually:

[source,kotlin]
.Opening an existing database:
----
val db = DB.open("path/to/db", LevelDB.OpenPolicy.OPEN)
----



== Advanced usage

=== Handling the cache

Kodein-DB provides an object-cache that reflects the data that is serialized inside the database. +
When querying for a data (either by `DB.get` or `DB.find`) if the needed data is already in the cache, then instead of de-serializing it, Kodein-DB immediately returns the cached value.

Kodein-DB updates the cache:
- at every `put` (both the database and the cache save the model)
- at every `get` or `find` (if the model is not in the cache, then the cache saves the model to prevent any future deserialization).

This enhances performances as deserialization is one of the most expensive operations.

You may want to define the maximum size of the cache:

[source,kotlin]
.Opening a database:
----
val db = DB.open(
    "path/to/db",
    ModelCache.MaxSize(Runtime.getRuntime().totalMemory() / 8) //<1>
)
----
<1> Default on JVM & Android.

The cache also works on snapshots (remember: Kodein-DB automatically uses a snapshot when using a cursor or a sequence).
When you create a snapshot (or a cursor), it uses the same cache. +
However, if you mutate the database while holding a snapshot, than the cache must be copied in order for the snapshot to use a cache that only reflects the database when it was created.
This is a rare case (if you correctly close your cursors / snapshots) and only object references are copied, so the process itself is as optimised as can be.
However, you may need to handle the size of these snapshot-specific copies.

[source,kotlin]
.Opening a database:
----
val cacheSize = Runtime.getRuntime().totalMemory() / 8
val db = DB.open(
    "path/to/db",
    ModelCache.MaxSize(cacheSize),
    ModelCache.CopyMaxSize(cacheSize / 4) //<1>
)
----
<1> Default on JVM & Android.

However, there are times when you may want to bypass the cache:

- When you *put* a model you won't need in the future:
+
[source,kotlin]
.Bypassing the cache:
----
db.put(model, ModelCache.Skip)
----
+
- When you *get* a model you won't query again in the future:
+
[source,kotlin]
.Bypassing the cache:
----
val m1 = db.get(model, ModelCache.Skip) //<1>
val m2 = db.get(model, ModelCache.Refresh) //<2>
----
<1> Skips the cache (and removes any cached value).
<2> Forces the cache to refresh from the serialized model in DB.

Of course, if you don't want any caching, you can simply disable the cache:

[source,kotlin]
.Disabling the cache:
----
val cacheSize = Runtime.getRuntime().totalMemory() / 8
val db = DB.open(
    "path/to/db",
    ModelCache.Disable
)
----
